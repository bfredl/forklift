- port "delete unused critical node" from Eiri
- calls:
  - make FLIR entirely "post call-convention".
  - All info of (1) args (2) clobbers (3) return register(s?) should be encoded
  into relevant instructions.
  - vregs+temps then both need bitsets for all clobbered regs, not just "overlaps a call" bit
   - free bonus: handle constrained instructions like "shr reg, ECX" properly

  - make ParseIR handle multiple functions seamlessly

- FIXME: general paralell move handling. paralell moves currently needs to be handled:
  - block of putphi instructions
  - block of callarg instructions
  - block of arg instructions (we shouldn't need to do swaps here, but why not support to)

- strech: make FLIR.zig ABI general. all ABI info should be on self.abi field
  (enum desicions between amd64, aarch64 and EBPF are fine for now)

- regalloc:
 - implement dummy "spill everything!" allocator just to test spill code in isolation

 -implement liveness interval spliting:
   - implement block-splitting to insert insns in the middle of a node [DONE]
   - "%b = copy %a" instruction [-]
     - for node-locals, rename all %a to %b later in the node
     - for vregs: introduce some kind of vreg-to-ref table per node?
 - mostly following "Linear Scan Register Allocation on SSA Form"; Wimmer, Franz; 2010
   - [DONE] allocation when no spilling is needed
 - consider "call near" test case as of 638022887f2f060ecf6eb0aacf211f93a05ed89a:
        \\func twokube
        \\  %x = arg
        \\  %y = arg
        \\  %xx = call kuben %x
        \\  %yy = call kuben %y
        \\  %summa = add %xx %yy
        \\  ret %summa
        \\end
   - this uses two saved regs (for $xx and $y overlapping), but in theory only one is needed
     (between the calls, $y could be moved from SAVED to .rdi and then %xx from .rax to SAVED)
   - make a test case where we actually hit the register limit
   - for this case: allow interval to be split into two distinct registers, whithout any memory spilling

 - follow up project: attempt to generalize reverse-mode linear scan to general (at least reducible) CFG:s.
  (only worth it if the struct/algo becomes simpler than

Long term: integrate codebase completely with EIRI. Try zig package manager and see make Eiri depend on FLIR

pub fn vmovdq_vg(self: *Self, quad: bool, dst: u4, src: IPReg) !void {
    try self.new_inst(@returnAddress());
    try self.vex3(wide, dst.ext(), src1.ext(), false, .h0F38, src2.id(), false, pp);
}


std.debug.print("\nnee: {}", .{std.os.system.getpid()});
std.time.sleep(1000 * 1e9);
